{
  "version": 3,
  "sources": ["../../three/examples/jsm/tsl/display/BloomNode.js"],
  "sourcesContent": ["import { HalfFloatType, RenderTarget, Vector2, Vector3, TempNode, QuadMesh, NodeMaterial, RendererUtils, NodeUpdateType } from 'three/webgpu';\nimport { nodeObject, Fn, float, uv, passTexture, uniform, Loop, texture, luminance, smoothstep, mix, vec4, uniformArray, add, int } from 'three/tsl';\n\nconst _quadMesh = /*@__PURE__*/ new QuadMesh();\nconst _size = /*@__PURE__*/ new Vector2();\n\nconst _BlurDirectionX = /*@__PURE__*/ new Vector2( 1.0, 0.0 );\nconst _BlurDirectionY = /*@__PURE__*/ new Vector2( 0.0, 1.0 );\n\nlet _rendererState;\n\n/**\n * Post processing node for creating a bloom effect.\n * ```js\n * const postProcessing = new THREE.PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n * const scenePassColor = scenePass.getTextureNode( 'output' );\n *\n * const bloomPass = bloom( scenePassColor );\n *\n * postProcessing.outputNode = scenePassColor.add( bloomPass );\n * ```\n * By default, the node affects the entire image. For a selective bloom,\n * use the `emissive` material property to control which objects should\n * contribute to bloom or not. This can be achieved via MRT.\n * ```js\n * const postProcessing = new THREE.PostProcessing( renderer );\n *\n * const scenePass = pass( scene, camera );\n * scenePass.setMRT( mrt( {\n * \toutput,\n * \temissive\n * } ) );\n *\n * const scenePassColor = scenePass.getTextureNode( 'output' );\n * const emissivePass = scenePass.getTextureNode( 'emissive' );\n *\n * const bloomPass = bloom( emissivePass );\n * postProcessing.outputNode = scenePassColor.add( bloomPass );\n * ```\n * @augments TempNode\n * @three_import import { bloom } from 'three/addons/tsl/display/BloomNode.js';\n */\nclass BloomNode extends TempNode {\n\n\tstatic get type() {\n\n\t\treturn 'BloomNode';\n\n\t}\n\n\t/**\n\t * Constructs a new bloom node.\n\t *\n\t * @param {Node<vec4>} inputNode - The node that represents the input of the effect.\n\t * @param {number} [strength=1] - The strength of the bloom.\n\t * @param {number} [radius=0] - The radius of the bloom.\n\t * @param {number} [threshold=0] - The luminance threshold limits which bright areas contribute to the bloom effect.\n\t */\n\tconstructor( inputNode, strength = 1, radius = 0, threshold = 0 ) {\n\n\t\tsuper( 'vec4' );\n\n\t\t/**\n\t\t * The node that represents the input of the effect.\n\t\t *\n\t\t * @type {Node<vec4>}\n\t\t */\n\t\tthis.inputNode = inputNode;\n\n\t\t/**\n\t\t * The strength of the bloom.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.strength = uniform( strength );\n\n\t\t/**\n\t\t * The radius of the bloom. Must be in the range `[0,1]`.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.radius = uniform( radius );\n\n\t\t/**\n\t\t * The luminance threshold limits which bright areas contribute to the bloom effect.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.threshold = uniform( threshold );\n\n\t\t/**\n\t\t * Can be used to tweak the extracted luminance from the scene.\n\t\t *\n\t\t * @type {UniformNode<float>}\n\t\t */\n\t\tthis.smoothWidth = uniform( 0.01 );\n\n\t\t/**\n\t\t * An array that holds the render targets for the horizontal blur passes.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<RenderTarget>}\n\t\t */\n\t\tthis._renderTargetsHorizontal = [];\n\n\t\t/**\n\t\t * An array that holds the render targets for the vertical blur passes.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<RenderTarget>}\n\t\t */\n\t\tthis._renderTargetsVertical = [];\n\n\t\t/**\n\t\t * The number if blur mips.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t */\n\t\tthis._nMips = 5;\n\n\t\t/**\n\t\t * The render target for the luminance pass.\n\t\t *\n\t\t * @private\n\t\t * @type {RenderTarget}\n\t\t */\n\t\tthis._renderTargetBright = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\t\tthis._renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis._renderTargetBright.texture.generateMipmaps = false;\n\n\t\t//\n\n\t\tfor ( let i = 0; i < this._nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizontal = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\n\t\t\trenderTargetHorizontal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizontal.texture.generateMipmaps = false;\n\n\t\t\tthis._renderTargetsHorizontal.push( renderTargetHorizontal );\n\n\t\t\tconst renderTargetVertical = new RenderTarget( 1, 1, { depthBuffer: false, type: HalfFloatType } );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis._renderTargetsVertical.push( renderTargetVertical );\n\n\t\t}\n\n\t\t/**\n\t\t * The material for the composite pass.\n\t\t *\n\t\t * @private\n\t\t * @type {?NodeMaterial}\n\t\t */\n\t\tthis._compositeMaterial = null;\n\n\t\t/**\n\t\t * The material for the luminance pass.\n\t\t *\n\t\t * @private\n\t\t * @type {?NodeMaterial}\n\t\t */\n\t\tthis._highPassFilterMaterial = null;\n\n\t\t/**\n\t\t * The materials for the blur pass.\n\t\t *\n\t\t * @private\n\t\t * @type {Array<NodeMaterial>}\n\t\t */\n\t\tthis._separableBlurMaterials = [];\n\n\t\t/**\n\t\t * The result of the luminance pass as a texture node for further processing.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeBright = texture( this._renderTargetBright.texture );\n\n\t\t/**\n\t\t * The result of the first blur pass as a texture node for further processing.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeBlur0 = texture( this._renderTargetsVertical[ 0 ].texture );\n\n\t\t/**\n\t\t * The result of the second blur pass as a texture node for further processing.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeBlur1 = texture( this._renderTargetsVertical[ 1 ].texture );\n\n\t\t/**\n\t\t * The result of the third blur pass as a texture node for further processing.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeBlur2 = texture( this._renderTargetsVertical[ 2 ].texture );\n\n\t\t/**\n\t\t * The result of the fourth blur pass as a texture node for further processing.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeBlur3 = texture( this._renderTargetsVertical[ 3 ].texture );\n\n\t\t/**\n\t\t * The result of the fifth blur pass as a texture node for further processing.\n\t\t *\n\t\t * @private\n\t\t * @type {TextureNode}\n\t\t */\n\t\tthis._textureNodeBlur4 = texture( this._renderTargetsVertical[ 4 ].texture );\n\n\t\t/**\n\t\t * The result of the effect is represented as a separate texture node.\n\t\t *\n\t\t * @private\n\t\t * @type {PassTextureNode}\n\t\t */\n\t\tthis._textureOutput = passTexture( this, this._renderTargetsHorizontal[ 0 ].texture );\n\n\t\t/**\n\t\t * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders\n\t\t * its effect once per frame in `updateBefore()`.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'frame'\n\t\t */\n\t\tthis.updateBeforeType = NodeUpdateType.FRAME;\n\n\t}\n\n\t/**\n\t * Returns the result of the effect as a texture node.\n\t *\n\t * @return {PassTextureNode} A texture node that represents the result of the effect.\n\t */\n\tgetTextureNode() {\n\n\t\treturn this._textureOutput;\n\n\t}\n\n\t/**\n\t * Sets the size of the effect.\n\t *\n\t * @param {number} width - The width of the effect.\n\t * @param {number} height - The height of the effect.\n\t */\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis._renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this._nMips; i ++ ) {\n\n\t\t\tthis._renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis._renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis._separableBlurMaterials[ i ].invSize.value.set( 1 / resx, 1 / resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This method is used to render the effect once per frame.\n\t *\n\t * @param {NodeFrame} frame - The current node frame.\n\t */\n\tupdateBefore( frame ) {\n\n\t\tconst { renderer } = frame;\n\n\t\t_rendererState = RendererUtils.resetRendererState( renderer, _rendererState );\n\n\t\t//\n\n\t\tconst size = renderer.getDrawingBufferSize( _size );\n\t\tthis.setSize( size.width, size.height );\n\n\t\t// 1. Extract bright areas\n\n\t\trenderer.setRenderTarget( this._renderTargetBright );\n\t\t_quadMesh.material = this._highPassFilterMaterial;\n\t\t_quadMesh.name = 'Bloom [ High Pass ]';\n\t\t_quadMesh.render( renderer );\n\n\t\t// 2. Blur all the mips progressively\n\n\t\tlet inputRenderTarget = this._renderTargetBright;\n\n\t\tfor ( let i = 0; i < this._nMips; i ++ ) {\n\n\t\t\t_quadMesh.material = this._separableBlurMaterials[ i ];\n\n\t\t\tthis._separableBlurMaterials[ i ].colorTexture.value = inputRenderTarget.texture;\n\t\t\tthis._separableBlurMaterials[ i ].direction.value = _BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this._renderTargetsHorizontal[ i ] );\n\t\t\t_quadMesh.name = `Bloom [ Blur Horizontal - ${ i } ]`;\n\t\t\t_quadMesh.render( renderer );\n\n\t\t\tthis._separableBlurMaterials[ i ].colorTexture.value = this._renderTargetsHorizontal[ i ].texture;\n\t\t\tthis._separableBlurMaterials[ i ].direction.value = _BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this._renderTargetsVertical[ i ] );\n\t\t\t_quadMesh.name = `Bloom [ Blur Vertical - ${ i } ]`;\n\t\t\t_quadMesh.render( renderer );\n\n\t\t\tinputRenderTarget = this._renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// 3. Composite all the mips\n\n\t\trenderer.setRenderTarget( this._renderTargetsHorizontal[ 0 ] );\n\t\t_quadMesh.material = this._compositeMaterial;\n\t\t_quadMesh.name = 'Bloom [ Composite ]';\n\t\t_quadMesh.render( renderer );\n\n\t\t// restore\n\n\t\tRendererUtils.restoreRendererState( renderer, _rendererState );\n\n\t}\n\n\t/**\n\t * This method is used to setup the effect's TSL code.\n\t *\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @return {PassTextureNode}\n\t */\n\tsetup( builder ) {\n\n\t\t// luminosity high pass material\n\n\t\tconst luminosityHighPass = Fn( () => {\n\n\t\t\tconst texel = this.inputNode;\n\t\t\tconst v = luminance( texel.rgb );\n\n\t\t\tconst alpha = smoothstep( this.threshold, this.threshold.add( this.smoothWidth ), v );\n\n\t\t\treturn mix( vec4( 0 ), texel, alpha );\n\n\t\t} );\n\n\t\tthis._highPassFilterMaterial = this._highPassFilterMaterial || new NodeMaterial();\n\t\tthis._highPassFilterMaterial.fragmentNode = luminosityHighPass().context( builder.getSharedContext() );\n\t\tthis._highPassFilterMaterial.name = 'Bloom_highPass';\n\t\tthis._highPassFilterMaterial.needsUpdate = true;\n\n\t\t// gaussian blur materials\n\n\t\t// These sizes have been changed to account for the altered coefficients-calculation to avoid blockiness,\n\t\t// while retaining the same blur-strength. For details see https://github.com/mrdoob/three.js/pull/31528\n\t\tconst kernelSizeArray = [ 6, 10, 14, 18, 22 ];\n\n\t\tfor ( let i = 0; i < this._nMips; i ++ ) {\n\n\t\t\tthis._separableBlurMaterials.push( this._getSeparableBlurMaterial( builder, kernelSizeArray[ i ] ) );\n\n\t\t}\n\n\t\t// composite material\n\n\t\tconst bloomFactors = uniformArray( [ 1.0, 0.8, 0.6, 0.4, 0.2 ] );\n\t\tconst bloomTintColors = uniformArray( [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ] );\n\n\t\tconst lerpBloomFactor = Fn( ( [ factor, radius ] ) => {\n\n\t\t\tconst mirrorFactor = float( 1.2 ).sub( factor );\n\t\t\treturn mix( factor, mirrorFactor, radius );\n\n\t\t} ).setLayout( {\n\t\t\tname: 'lerpBloomFactor',\n\t\t\ttype: 'float',\n\t\t\tinputs: [\n\t\t\t\t{ name: 'factor', type: 'float' },\n\t\t\t\t{ name: 'radius', type: 'float' },\n\t\t\t]\n\t\t} );\n\n\n\t\tconst compositePass = Fn( () => {\n\n\t\t\tconst color0 = lerpBloomFactor( bloomFactors.element( 0 ), this.radius ).mul( vec4( bloomTintColors.element( 0 ), 1.0 ) ).mul( this._textureNodeBlur0 );\n\t\t\tconst color1 = lerpBloomFactor( bloomFactors.element( 1 ), this.radius ).mul( vec4( bloomTintColors.element( 1 ), 1.0 ) ).mul( this._textureNodeBlur1 );\n\t\t\tconst color2 = lerpBloomFactor( bloomFactors.element( 2 ), this.radius ).mul( vec4( bloomTintColors.element( 2 ), 1.0 ) ).mul( this._textureNodeBlur2 );\n\t\t\tconst color3 = lerpBloomFactor( bloomFactors.element( 3 ), this.radius ).mul( vec4( bloomTintColors.element( 3 ), 1.0 ) ).mul( this._textureNodeBlur3 );\n\t\t\tconst color4 = lerpBloomFactor( bloomFactors.element( 4 ), this.radius ).mul( vec4( bloomTintColors.element( 4 ), 1.0 ) ).mul( this._textureNodeBlur4 );\n\n\t\t\tconst sum = color0.add( color1 ).add( color2 ).add( color3 ).add( color4 );\n\n\t\t\treturn sum.mul( this.strength );\n\n\t\t} );\n\n\t\tthis._compositeMaterial = this._compositeMaterial || new NodeMaterial();\n\t\tthis._compositeMaterial.fragmentNode = compositePass().context( builder.getSharedContext() );\n\t\tthis._compositeMaterial.name = 'Bloom_comp';\n\t\tthis._compositeMaterial.needsUpdate = true;\n\n\t\t//\n\n\t\treturn this._textureOutput;\n\n\t}\n\n\t/**\n\t * Frees internal resources. This method should be called\n\t * when the effect is no longer required.\n\t */\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this._renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis._renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this._renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis._renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis._renderTargetBright.dispose();\n\n\t\tif ( this._highPassFilterMaterial !== null ) this._highPassFilterMaterial.dispose();\n\t\tif ( this._compositeMaterial !== null ) this._compositeMaterial.dispose();\n\n\t\tfor ( let i = 0; i < this._separableBlurMaterials.length; i ++ ) {\n\n\t\t\tthis._separableBlurMaterials[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Create a separable blur material for the given kernel radius.\n\t *\n\t * @private\n\t * @param {NodeBuilder} builder - The current node builder.\n\t * @param {number} kernelRadius - The kernel radius.\n\t * @return {NodeMaterial}\n\t */\n\t_getSeparableBlurMaterial( builder, kernelRadius ) {\n\n\t\tconst coefficients = [];\n\t\tconst sigma = kernelRadius / 3;\n\n\t\tfor ( let i = 0; i < kernelRadius; i ++ ) {\n\n\t\t\tcoefficients.push( 0.39894 * Math.exp( - 0.5 * i * i / ( sigma * sigma ) ) / sigma );\n\n\t\t}\n\n\t\t//\n\n\t\tconst colorTexture = texture( null );\n\t\tconst gaussianCoefficients = uniformArray( coefficients );\n\t\tconst invSize = uniform( new Vector2() );\n\t\tconst direction = uniform( new Vector2( 0.5, 0.5 ) );\n\n\t\tconst uvNode = uv();\n\t\tconst sampleTexel = ( uv ) => colorTexture.sample( uv );\n\n\t\tconst separableBlurPass = Fn( () => {\n\n\t\t\tconst diffuseSum = sampleTexel( uvNode ).rgb.mul( gaussianCoefficients.element( 0 ) ).toVar();\n\n\t\t\tLoop( { start: int( 1 ), end: int( kernelRadius ), type: 'int', condition: '<' }, ( { i } ) => {\n\n\t\t\t\tconst x = float( i );\n\t\t\t\tconst w = gaussianCoefficients.element( i );\n\t\t\t\tconst uvOffset = direction.mul( invSize ).mul( x );\n\t\t\t\tconst sample1 = sampleTexel( uvNode.add( uvOffset ) ).rgb;\n\t\t\t\tconst sample2 = sampleTexel( uvNode.sub( uvOffset ) ).rgb;\n\t\t\t\tdiffuseSum.addAssign( add( sample1, sample2 ).mul( w ) );\n\n\t\t\t} );\n\n\t\t\treturn vec4( diffuseSum, 1.0 );\n\n\t\t} );\n\n\t\tconst separableBlurMaterial = new NodeMaterial();\n\t\tseparableBlurMaterial.fragmentNode = separableBlurPass().context( builder.getSharedContext() );\n\t\tseparableBlurMaterial.name = 'Bloom_separable';\n\t\tseparableBlurMaterial.needsUpdate = true;\n\n\t\t// uniforms\n\t\tseparableBlurMaterial.colorTexture = colorTexture;\n\t\tseparableBlurMaterial.direction = direction;\n\t\tseparableBlurMaterial.invSize = invSize;\n\n\t\treturn separableBlurMaterial;\n\n\t}\n\n}\n\n/**\n * TSL function for creating a bloom effect.\n *\n * @tsl\n * @function\n * @param {Node<vec4>} node - The node that represents the input of the effect.\n * @param {number} [strength=1] - The strength of the bloom.\n * @param {number} [radius=0] - The radius of the bloom.\n * @param {number} [threshold=0] - The luminance threshold limits which bright areas contribute to the bloom effect.\n * @returns {BloomNode}\n */\nexport const bloom = ( node, strength, radius, threshold ) => nodeObject( new BloomNode( nodeObject( node ), strength, radius, threshold ) );\n\nexport default BloomNode;\n"],
  "mappings": "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",
  "names": ["uv"]
}
