<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PBR Texture Generator Demo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      padding: 20px;
    }
    h1 { margin-bottom: 20px; }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    .input-section {
      margin-bottom: 20px;
      padding: 20px;
      background: #16213e;
      border-radius: 10px;
    }
    .input-section input[type="file"] {
      padding: 10px;
      background: #0f3460;
      border: none;
      border-radius: 5px;
      color: #eee;
      cursor: pointer;
    }
    .export-section {
      margin-bottom: 30px;
      padding: 20px;
      background: #16213e;
      border-radius: 10px;
      display: none;
    }
    .export-section.visible {
      display: block;
    }
    .export-row {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: center;
    }
    .export-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .export-group label {
      font-size: 14px;
      color: #aaa;
    }
    .export-group input[type="text"] {
      padding: 8px 12px;
      background: #0f3460;
      border: 1px solid #1a4a7a;
      border-radius: 5px;
      color: #eee;
      width: 150px;
    }
    .export-group input[type="range"] {
      width: 100px;
      accent-color: #e94560;
    }
    .export-group select {
      padding: 8px 12px;
      background: #0f3460;
      border: 1px solid #1a4a7a;
      border-radius: 5px;
      color: #eee;
      cursor: pointer;
    }
    .toggle-group {
      display: flex;
      background: #0f3460;
      border-radius: 5px;
      overflow: hidden;
    }
    .toggle-group button {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: #888;
      cursor: pointer;
      transition: all 0.2s;
    }
    .toggle-group button.active {
      background: #e94560;
      color: white;
    }
    .download-all-btn {
      padding: 12px 24px;
      background: #e94560;
      border: none;
      border-radius: 5px;
      color: white;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
    }
    .download-all-btn:hover {
      background: #ff6b6b;
    }
    .download-all-btn:disabled {
      background: #555;
      cursor: not-allowed;
    }
    .file-size-info {
      font-size: 12px;
      color: #888;
      margin-top: 10px;
    }
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
    }
    .preview-card {
      background: #16213e;
      border-radius: 10px;
      padding: 15px;
      text-align: center;
    }
    .preview-card h3 {
      margin-bottom: 10px;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #e94560;
    }
    .preview-card canvas {
      max-width: 100%;
      height: auto;
      border-radius: 5px;
      background: #0f0f0f;
    }
    .preview-card .card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
    }
    .preview-card .file-size {
      font-size: 11px;
      color: #888;
    }
    .preview-card button {
      padding: 8px 16px;
      background: #e94560;
      border: none;
      border-radius: 5px;
      color: white;
      cursor: pointer;
      font-size: 12px;
    }
    .preview-card button:hover {
      background: #ff6b6b;
    }
    #three-preview {
      width: 100%;
      height: 400px;
      border-radius: 10px;
      margin-top: 30px;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #888;
    }
    .checkbox-group {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
    }
    .checkbox-group label {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      font-size: 13px;
    }
    .checkbox-group input[type="checkbox"] {
      accent-color: #e94560;
      width: 16px;
      height: 16px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>PBR Texture Generator Demo</h1>

    <div class="input-section">
      <input type="file" id="imageInput" accept="image/*">
      <span style="margin-left: 15px; color: #888;">Upload a diffuse/albedo texture to generate PBR maps</span>
    </div>

    <div class="export-section" id="exportSection">
      <div class="export-row">
        <div class="export-group">
          <label>Prefix:</label>
          <input type="text" id="filePrefix" value="texture" placeholder="texture">
        </div>

        <div class="export-group">
          <label>Format:</label>
          <div class="toggle-group">
            <button id="btnPNG" class="active">PNG</button>
            <button id="btnJPG">JPG</button>
          </div>
        </div>

        <div class="export-group" id="qualityGroup" style="display: none;">
          <label>Quality:</label>
          <input type="range" id="jpgQuality" min="10" max="100" value="85">
          <span id="qualityValue">85%</span>
        </div>

        <button class="download-all-btn" id="downloadAllBtn">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7 10 12 15 17 10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
          </svg>
          Download All as ZIP
        </button>
      </div>

      <div class="export-row" style="margin-top: 15px;">
        <div class="export-group">
          <label>Include:</label>
          <div class="checkbox-group">
            <label><input type="checkbox" id="incDiffuse" checked> Diffuse</label>
            <label><input type="checkbox" id="incNormal" checked> Normal</label>
            <label><input type="checkbox" id="incMetallicRoughness" checked> Metallic-Roughness</label>
            <label><input type="checkbox" id="incHeight"> Height</label>
            <label><input type="checkbox" id="incAO" checked> AO</label>
          </div>
        </div>
      </div>

      <div class="file-size-info" id="totalSizeInfo"></div>
    </div>

    <div class="preview-grid" id="previewGrid">
      <div class="loading">Upload an image to see generated PBR maps</div>
    </div>

    <canvas id="three-preview"></canvas>
  </div>

  <!-- JSZip for creating zip files -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three'
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js'

    // Import PBR generator functions directly (standalone mode)
    import {
      generateNormalMapCanvas,
      generateMetallicRoughnessMapCanvas,
      generateHeightMapCanvas,
      generateAOMapCanvas,
      generatePBRMaps
    } from './src/utils/PBRTextureGenerator.js'

    // State
    let currentFormat = 'png'
    let jpgQuality = 0.85
    let currentMaps = null
    let diffuseCanvas = null

    // Three.js scene setup for preview
    let scene, camera, renderer, controls, mesh

    function initThreeJS() {
      const canvas = document.getElementById('three-preview')

      scene = new THREE.Scene()
      scene.background = new THREE.Color(0x1a1a2e)

      camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 100)
      camera.position.set(0, 0, 3)

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true })
      renderer.setSize(canvas.clientWidth, canvas.clientHeight)
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

      controls = new OrbitControls(camera, canvas)
      controls.enableDamping = true

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3)
      scene.add(ambientLight)

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1)
      directionalLight.position.set(5, 5, 5)
      scene.add(directionalLight)

      const directionalLight2 = new THREE.DirectionalLight(0x4488ff, 0.5)
      directionalLight2.position.set(-5, 3, -5)
      scene.add(directionalLight2)

      // Create sphere with placeholder material
      const geometry = new THREE.SphereGeometry(1, 64, 64)
      // Copy uv to uv2 for AO map support
      geometry.setAttribute('uv2', geometry.attributes.uv)

      const material = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.5,
        metalness: 0.0,
      })
      mesh = new THREE.Mesh(geometry, material)
      scene.add(mesh)

      function animate() {
        requestAnimationFrame(animate)
        controls.update()
        mesh.rotation.y += 0.003
        renderer.render(scene, camera)
      }
      animate()

      window.addEventListener('resize', () => {
        camera.aspect = canvas.clientWidth / canvas.clientHeight
        camera.updateProjectionMatrix()
        renderer.setSize(canvas.clientWidth, canvas.clientHeight)
      })
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B'
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB'
      return (bytes / (1024 * 1024)).toFixed(2) + ' MB'
    }

    function getCanvasBlob(canvas, format, quality) {
      return new Promise(resolve => {
        const mimeType = format === 'jpg' ? 'image/jpeg' : 'image/png'
        canvas.toBlob(blob => resolve(blob), mimeType, quality)
      })
    }

    function getCanvasDataURL(canvas) {
      const mimeType = currentFormat === 'jpg' ? 'image/jpeg' : 'image/png'
      return canvas.toDataURL(mimeType, currentFormat === 'jpg' ? jpgQuality : undefined)
    }

    async function getCanvasSize(canvas) {
      const blob = await getCanvasBlob(canvas, currentFormat, jpgQuality)
      return blob.size
    }

    function createPreviewCard(title, canvas, mapKey) {
      const card = document.createElement('div')
      card.className = 'preview-card'
      card.dataset.mapKey = mapKey

      const h3 = document.createElement('h3')
      h3.textContent = title

      const footer = document.createElement('div')
      footer.className = 'card-footer'

      const sizeSpan = document.createElement('span')
      sizeSpan.className = 'file-size'
      sizeSpan.textContent = 'Calculating...'

      const button = document.createElement('button')
      button.textContent = 'Download'
      button.onclick = () => {
        const prefix = document.getElementById('filePrefix').value || 'texture'
        const ext = currentFormat
        const link = document.createElement('a')
        link.download = `${prefix}_${mapKey}.${ext}`
        link.href = getCanvasDataURL(canvas)
        link.click()
      }

      footer.appendChild(sizeSpan)
      footer.appendChild(button)

      card.appendChild(h3)
      card.appendChild(canvas)
      card.appendChild(footer)

      // Calculate file size async
      getCanvasSize(canvas).then(size => {
        sizeSpan.textContent = formatFileSize(size)
      })

      return card
    }

    async function updateFileSizes() {
      if (!currentMaps) return

      const allMaps = {
        diffuse: diffuseCanvas,
        normal: currentMaps.normal,
        metallicRoughness: currentMaps.metallicRoughness,
        height: currentMaps.height,
        ao: currentMaps.ao
      }

      let totalSize = 0
      const checkboxes = {
        diffuse: document.getElementById('incDiffuse'),
        normal: document.getElementById('incNormal'),
        metallicRoughness: document.getElementById('incMetallicRoughness'),
        height: document.getElementById('incHeight'),
        ao: document.getElementById('incAO')
      }

      // Update individual card sizes
      const cards = document.querySelectorAll('.preview-card')
      for (const card of cards) {
        const mapKey = card.dataset.mapKey
        if (allMaps[mapKey]) {
          const size = await getCanvasSize(allMaps[mapKey])
          const sizeSpan = card.querySelector('.file-size')
          if (sizeSpan) sizeSpan.textContent = formatFileSize(size)

          if (checkboxes[mapKey] && checkboxes[mapKey].checked) {
            totalSize += size
          }
        }
      }

      // Update total size info
      document.getElementById('totalSizeInfo').textContent =
        `Estimated ZIP size: ~${formatFileSize(totalSize)} (${currentFormat.toUpperCase()}${currentFormat === 'jpg' ? ` @ ${Math.round(jpgQuality * 100)}%` : ''})`
    }

    function processImage(image) {
      try {
        const grid = document.getElementById('previewGrid')
        grid.innerHTML = ''

        // Show export section
        document.getElementById('exportSection').classList.add('visible')

        // Generate all maps
        console.time('PBR Generation')
        currentMaps = generatePBRMaps(image, {
          normal: { strength: 2.0, blur: 0 },
          roughness: { contrast: 1.0, brightness: 0, invert: true, blur: 0 },
          metallic: { threshold: 0.5, contrast: 1.5, blur: 1 },
          height: { contrast: 1.0, blur: 1 },
          ao: { strength: 1.0, radius: 5 }
        })
        console.timeEnd('PBR Generation')
        console.log('Generated maps:', Object.keys(currentMaps))

      // Create diffuse preview
      diffuseCanvas = document.createElement('canvas')
      diffuseCanvas.width = image.width
      diffuseCanvas.height = image.height
      const ctx = diffuseCanvas.getContext('2d')
      ctx.drawImage(image, 0, 0)

      // Add preview cards
      grid.appendChild(createPreviewCard('Diffuse (Original)', diffuseCanvas, 'diffuse'))
      grid.appendChild(createPreviewCard('Normal Map', currentMaps.normal, 'normal'))
      grid.appendChild(createPreviewCard('Metallic-Roughness (G=rough, B=metal)', currentMaps.metallicRoughness, 'metallicRoughness'))
      grid.appendChild(createPreviewCard('Height Map', currentMaps.height, 'height'))
      grid.appendChild(createPreviewCard('Ambient Occlusion', currentMaps.ao, 'ao'))

      // Update Three.js preview
      if (mesh) {
        const textureFromCanvas = (canvas) => {
          const texture = new THREE.CanvasTexture(canvas)
          texture.colorSpace = THREE.LinearSRGBColorSpace
          texture.needsUpdate = true
          return texture
        }

        mesh.material.map = textureFromCanvas(diffuseCanvas)
        mesh.material.map.colorSpace = THREE.SRGBColorSpace
        mesh.material.normalMap = textureFromCanvas(currentMaps.normal)
        // Combined texture: G=roughness, B=metallic
        const mrTexture = textureFromCanvas(currentMaps.metallicRoughness)
        mesh.material.roughnessMap = mrTexture
        mesh.material.metalnessMap = mrTexture
        mesh.material.aoMap = textureFromCanvas(currentMaps.ao)
        mesh.material.needsUpdate = true
      }

      // Update file sizes
      updateFileSizes()
      } catch (error) {
        console.error('Error processing image:', error)
        alert('Error generating PBR maps: ' + error.message)
      }
    }

    async function downloadAllAsZip() {
      if (!currentMaps || !diffuseCanvas) return

      const btn = document.getElementById('downloadAllBtn')
      btn.disabled = true
      btn.innerHTML = 'Creating ZIP...'

      try {
        const zip = new JSZip()
        const prefix = document.getElementById('filePrefix').value || 'texture'
        const ext = currentFormat
        const mimeType = currentFormat === 'jpg' ? 'image/jpeg' : 'image/png'
        const quality = currentFormat === 'jpg' ? jpgQuality : undefined

        const maps = {
          diffuse: { canvas: diffuseCanvas, checkbox: document.getElementById('incDiffuse') },
          normal: { canvas: currentMaps.normal, checkbox: document.getElementById('incNormal') },
          metallicRoughness: { canvas: currentMaps.metallicRoughness, checkbox: document.getElementById('incMetallicRoughness') },
          height: { canvas: currentMaps.height, checkbox: document.getElementById('incHeight') },
          ao: { canvas: currentMaps.ao, checkbox: document.getElementById('incAO') }
        }

        for (const [key, { canvas, checkbox }] of Object.entries(maps)) {
          if (checkbox.checked) {
            const blob = await getCanvasBlob(canvas, currentFormat, jpgQuality)
            zip.file(`${prefix}_${key}.${ext}`, blob)
          }
        }

        const zipBlob = await zip.generateAsync({ type: 'blob' })

        // Download the zip
        const link = document.createElement('a')
        link.href = URL.createObjectURL(zipBlob)
        link.download = `${prefix}_pbr_textures.zip`
        link.click()
        URL.revokeObjectURL(link.href)

      } catch (error) {
        console.error('Error creating ZIP:', error)
        alert('Error creating ZIP file. See console for details.')
      }

      btn.disabled = false
      btn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="7 10 12 15 17 10"/>
          <line x1="12" y1="15" x2="12" y2="3"/>
        </svg>
        Download All as ZIP
      `
    }

    // Initialize
    initThreeJS()

    // Format toggle
    document.getElementById('btnPNG').addEventListener('click', () => {
      currentFormat = 'png'
      document.getElementById('btnPNG').classList.add('active')
      document.getElementById('btnJPG').classList.remove('active')
      document.getElementById('qualityGroup').style.display = 'none'
      updateFileSizes()
    })

    document.getElementById('btnJPG').addEventListener('click', () => {
      currentFormat = 'jpg'
      document.getElementById('btnJPG').classList.add('active')
      document.getElementById('btnPNG').classList.remove('active')
      document.getElementById('qualityGroup').style.display = 'flex'
      updateFileSizes()
    })

    // Quality slider
    document.getElementById('jpgQuality').addEventListener('input', (e) => {
      jpgQuality = e.target.value / 100
      document.getElementById('qualityValue').textContent = `${e.target.value}%`
      updateFileSizes()
    })

    // Checkbox changes
    document.querySelectorAll('.checkbox-group input').forEach(cb => {
      cb.addEventListener('change', updateFileSizes)
    })

    // Download all button
    document.getElementById('downloadAllBtn').addEventListener('click', downloadAllAsZip)

    // Handle file input
    document.getElementById('imageInput').addEventListener('change', (e) => {
      const file = e.target.files[0]
      if (!file) return

      // Set default prefix from filename
      const nameWithoutExt = file.name.replace(/\.[^/.]+$/, '')
      document.getElementById('filePrefix').value = nameWithoutExt

      const reader = new FileReader()
      reader.onload = (event) => {
        const image = new Image()
        image.onload = () => processImage(image)
        image.src = event.target.result
      }
      reader.readAsDataURL(file)
    })
  </script>
</body>
</html>
